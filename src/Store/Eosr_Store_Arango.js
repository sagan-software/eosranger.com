// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE
'use strict';

var Arangojs = require("arangojs");
var Eos_Types = require("@sagan-software/bs-eos/src/Eos_Types.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Json_decode = require("@glennsl/bs-json/src/Json_decode.bs.js");
var Json_encode = require("@glennsl/bs-json/src/Json_encode.bs.js");
var Js_primitive = require("bs-platform/lib/js/js_primitive.js");

var Cursor = /* module */[];

var Collection = /* module */[];

var Db = /* module */[];

var Arango = /* module */[
  /* Cursor */Cursor,
  /* Collection */Collection,
  /* Db */Db
];

function setupDatabase(client, dbName) {
  return client.useDatabase(dbName).exists().then((function (exists) {
                if (exists) {
                  return Promise.resolve(/* () */0);
                } else {
                  return client.createDatabase(dbName).then((function () {
                                return Promise.resolve(/* () */0);
                              }));
                }
              }));
}

function setupCollection(client, collectionName) {
  var collection = client.collection(collectionName);
  return collection.exists().then((function (exists) {
                if (exists) {
                  return Promise.resolve(/* () */0);
                } else {
                  return collection.create().then((function () {
                                return Promise.resolve(/* () */0);
                              }));
                }
              }));
}

function setup(client, dbName, _) {
  return setupDatabase(client, dbName).then((function () {
                return setupCollection(client, "blocks");
              }));
}

function blockKey(b) {
  var chainId = Eos_Types.ChainId[/* toString */4](b[/* chainId */0]);
  var blockNum = String(Eos_Types.BlockNum[/* toInt */4](b[/* blockNum */2]));
  return chainId + ("_" + blockNum);
}

function encodeBlock(b) {
  return Json_encode.object_(/* :: */[
              /* tuple */[
                "_key",
                blockKey(b)
              ],
              /* :: */[
                /* tuple */[
                  "chain_id",
                  Eos_Types.ChainId[/* encode */1](b[/* chainId */0])
                ],
                /* :: */[
                  /* tuple */[
                    "block_id",
                    Eos_Types.BlockId[/* encode */1](b[/* blockId */1])
                  ],
                  /* :: */[
                    /* tuple */[
                      "block_num",
                      Eos_Types.BlockNum[/* encode */1](b[/* blockNum */2])
                    ],
                    /* :: */[
                      /* tuple */[
                        "irreversible",
                        b[/* irreversible */3]
                      ],
                      /* :: */[
                        /* tuple */[
                          "data",
                          b[/* data */4]
                        ],
                        /* [] */0
                      ]
                    ]
                  ]
                ]
              ]
            ]);
}

function save(client, b) {
  var vars = Json_encode.object_(/* :: */[
        /* tuple */[
          "key",
          blockKey(b)
        ],
        /* :: */[
          /* tuple */[
            "block",
            encodeBlock(b)
          ],
          /* [] */0
        ]
      ]);
  return client.query("\n    UPSERT { _key: @key }\n    INSERT @block\n    UPDATE @block\n    IN blocks", vars).then((function () {
                return Promise.resolve(/* () */0);
              }));
}

function count(client, _) {
  return client.query("RETURN LENGTH(blocks)").then((function (prim) {
                  return prim.next();
                })).then((function (json) {
                return Promise.resolve(Belt_Option.getWithDefault(Belt_Option.map((json == null) ? undefined : Js_primitive.some(json), Json_decode.$$int), 0));
              }));
}

function scan(client, chainId, start, limit) {
  var vars = Json_encode.object_(/* :: */[
        /* tuple */[
          "chain_id",
          Eos_Types.ChainId[/* encode */1](chainId)
        ],
        /* :: */[
          /* tuple */[
            "start",
            Eos_Types.BlockNum[/* encode */1](start)
          ],
          /* :: */[
            /* tuple */[
              "limit",
              limit
            ],
            /* [] */0
          ]
        ]
      ]);
  return client.query("\n    FOR b IN blocks\n    FILTER b.chain_id == @chain_id\n    FILTER b.block_num >= @start\n    SORT b.block_num ASC\n    LIMIT @limit\n    RETURN b.block_num", vars).then((function (prim) {
                  return prim.all();
                })).then((function (json) {
                return Promise.resolve(Belt_Array.map(json, Eos_Types.BlockNum[/* decode */0]));
              }));
}

function Make(Args) {
  var client = new Arangojs.Database().useBasicAuth(Args[/* user */1], Args[/* pass */2]);
  var partial_arg = Args[/* db */0];
  var setup$1 = function (param) {
    return setup(client, partial_arg, param);
  };
  var count$1 = function (param) {
    return count(client, param);
  };
  var save$1 = function (param) {
    return save(client, param);
  };
  var scan$1 = function (param, param$1, param$2) {
    return scan(client, param, param$1, param$2);
  };
  return /* module */[
          /* setup */setup$1,
          /* count */count$1,
          /* save */save$1,
          /* scan */scan$1
        ];
}

exports.Arango = Arango;
exports.setupDatabase = setupDatabase;
exports.setupCollection = setupCollection;
exports.setup = setup;
exports.blockKey = blockKey;
exports.encodeBlock = encodeBlock;
exports.save = save;
exports.count = count;
exports.scan = scan;
exports.Make = Make;
/* arangojs Not a pure module */
